% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calibration.R
\name{calibration}
\alias{calibration}
\alias{calibrate}
\alias{Returns}
\alias{a}
\alias{list}
\alias{-}
\alias{stepfun:}
\alias{estimated}
\alias{step-functions}
\alias{('stepfun')}
\alias{for}
\alias{each}
\alias{class}
\alias{classes:}
\alias{the}
\alias{unique}
\alias{classes}
\alias{model:}
\alias{model/method}
\alias{type}
\alias{(string)}
\alias{xy:}
\alias{of}
\alias{data.frame's}
\alias{with}
\alias{predictions}
\alias{(pr)}
\alias{and}
\alias{probabilities}
\alias{success}
\alias{(only}
\alias{'bin'}
\alias{method)}
\title{Calibration (training)}
\usage{
calibration(
  pr,
  cl,
  weights = NULL,
  threshold = 10,
  method = "bin",
  breaks = nclass.Sturges,
  df = 3,
  ...
)
}
\arguments{
\item{pr}{matrix with probabilities for each class}

\item{cl}{class variable}

\item{weights}{counts}

\item{threshold}{do not calibrate if less then 'threshold' events}

\item{method}{either 'isotonic' (pava), 'logistic', 'mspline' (monotone spline), 'bin' (local constant)}

\item{breaks}{optional number of bins (only for method 'bin')}

\item{df}{degrees of freedom (only for spline methods)}

\item{...}{additional arguments to lower level functions}
}
\description{
Calibration for multiclassication methods
}
\details{
...
}
\examples{
sim1 <- function(n, beta=c(-3, rep(.5,10)), rho=.5) {
 p <- length(beta)-1
 xx <- lava::rmvn0(n,sigma=diag(nrow=p)*(1-rho)+rho)
 y <- rbinom(n, 1, lava::expit(cbind(1,xx)\%*\%beta))
 d <- data.frame(y=y, xx)
 names(d) <- c("y",paste0("x",1:p))
 return(d)
}

set.seed(1)
beta <- c(-2,rep(1,10))
d <- sim1(1e4, beta=beta)
a1 <- NB(y ~ ., data=d)
a2 <- glm(y ~ ., data=d, family=binomial)
## a3 <- randomForest(factor(y) ~ ., data=d, family=binomial)

d0 <- sim1(1e5, beta=beta)
p1 <- predict(a1, newdata=d0)
p2 <- predict(a2, newdata=d0, type="response")
## p3 <- predict(a3, newdata=d0, type="prob")

c2 <- calibration(p2, d0$y, method="isotonic")
c1 <- calibration(p1, d0$y, breaks=100)
if (interactive()) {
  plot(c1)
  plot(c2,col="red",add=TRUE)
  abline(a=0,b=1)##'
  with(c1$xy[[1]], points(pred,freq,type="b", col="red"))
}

set.seed(1)
beta <- c(-2,rep(1,10))
dd <- lava::csplit(sim1(6e4, beta=beta), k=3)
mod <- NB(y ~ ., data=dd[[1]])
p1 <- predict(mod, newdata=dd[[2]])
cal <- calibration(p1, dd[[2]]$y)
p2 <- predict(mod, newdata=dd[[3]])
pp <- predict(c1, p2)
cc <- calibration(pp, dd[[3]]$y)
if (interactive()) {##'
  plot(cal)
  plot(cc, add=TRUE, col="blue")
}
}
\author{
Klaus K. Holst
}
